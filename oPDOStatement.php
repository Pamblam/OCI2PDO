<?php

/**
 * This class simulates a PDOStatement object
 * To be constructed directly by the oPDO class
 */
class oPDOStatement implements Iterator{
	
	/**
	 * Private OCI connection
	 * @var OCI Connection identifier 
	 */
	private $ociConnection;
	
	/**
	 *The SQL statement we're executing
	 * @var string
	 */
	private $statement;
	
	/**
	 * The raw results from the executed query
	 * @var array
	 */
	private $resultSet = array();
	
	/**
	 * This is the result set to be used when the class is iterated upon
	 * This is generated by the rewind() method via fetchAll()
	 * @var type 
	 */
	private $fetchedResultSet = array();
	
	/**
	 * Keeps track of the current position in the result set
	 * @var int
	 */
	private $resultSetPointer = 0;
	
	/**
	 * The fetch mode to be used
	 * @var int
	 */
	private $fetchMode;
	
	/**
	 * Which column number to fetch if set via fetchMode()
	 * @var int 
	 */
	private $fetchColNo = 0;
	
	/**
	 * The name of the class to initiate with the results
	 * @var string 
	 */
	private $fetchClassName;
	
	/**
	 * The name of the function to call with the results
	 * @var string 
	 */
	private $fetchFunctionName;
	
	/**
	 * The $ctoargs argument used in fetchMode()
	 * @var array 
	 */
	private $fetchCtoargs;
	
	/**
	 * The object to fetch junk into as used in fetchMode()
	 * @var array 
	 */
	private $fetchObject;
	
	/**
	 * Array of references to bind results to
	 * @var type 
	 */
	private $bindReferences = array();
	
	/**
	 * List of input parameters
	 * @var array
	 */
	private $inputParameters = array();
	
	/**
	 * @param OCI Connection
	 * @param string $statement
	 */
	public function __construct($conn, $statement){
		$this->ociConnection = $conn;
		$this->statement = $statement;
		$this->fetchMode = oPDO::FETCH_BOTH;
	}
	
	/**
	 * Bind a value to be used in the statement	
	 * @param type $column
	 * @param type $param
	 * @param type $type
	 * @param type $maxlen - Ignored, polyfill purposes only
	 * @param type $driverdata - Ignored, polyfill purposes only
	 * @return bool 
	 */
	public function bindColumn($column, &$param, $type=false, $maxlen=false, $driverdata=false){
		$this->bindReferences[$column] = array("reference"=>&$param, "type"=>$type);
		return true;
	}
	
	/**
	 * Bind a parameter to the statement
	 * @param type $parameter
	 * @param type $variable
	 * @param type $data_type
	 * @param type $length
	 * @param type $driver_options
	 * @return bool
	 */
	public function bindParam($parameter, &$variable, $data_type=false, $length=false, $driver_options=false){
		if(!$data_type) $data_type = PDO::PARAM_STR;
		switch($data_type){
			case PDO::PARAM_BOOL:
				$inputParameters[$parameter] = !!$variable;
				break;
			case PDO::PARAM_NULL:
				$inputParameters[$parameter] = null;
				break;
			case PDO::PARAM_INT:
				$inputParameters[$parameter] = intval($variable);
				break;
			case PDO::PARAM_STR:
			case PDO::PARAM_LOB:
			default:
				$inputParameters[$parameter] = strval($variable);
				break;
		}
	}
	
	/**
	 * Bind a value to the statement
	 * @param type $parameter
	 * @param type $value
	 * @param type $data_type
	 * @return bool
	 */
	public function bindValue($parameter, $value, $data_type="String"){}
	
	/**
	 * Close the cursor
	 * @return bool
	 */
	public function closeCursor(){}
	
	/**
	 * get the column count
	 * @return int
	 */
	public function columnCount(){}
	
	/**
	 * @return void
	 */
	public function debugDumpParams(){}
	
	/**
	 * @return string
	 */
	public function errorCode(){}
	
	/**
	 * @return array
	 */
	public function errorInfo(){}
	
	/**
	 * Execute the query
	 * @param type $input_parameters
	 * @return bool
	 */
	public function execute($input_parameters = array()){
		if(!empty($input_parameters)) foreach($input_parameters as $k=>$k) $this->inputParameters[$k]=$v;
		if(!empty($this->inputParameters)){
			foreach($this->inputParameters as $k=>$v){
				oci_bind_by_name($stid, $k, $v);
			}
		}
		$stid = oci_parse($this->ociConnection, $this->statement);
		if(!$stid) return false;
		oci_execute($stid);
		$this->resultSet = array();
		while ($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) array_push($this->resultSet, $row);
		return true;
	}
	
	/**
	 * Get the next result in the thing
	 * @param type $fetch_style
	 * @param type $cursor_orientation - @todo Support scrollable cursor
	 * @param type $cursor_offset - @todo Support scrollable cursor
	 * @return mixed
	 */
	public function fetch($fetch_style=false, $cursor_orientation=false, $cursor_offset=0){
		if($fetch_style !== false) $this->setFetchMode($fetch_style);
		if($this->resultSetPointer >= count($this->resultSet)) return false;
		$r = $this->resultSet[$this->resultSetPointer];
		$return = true;
		switch($this->fetchMode){
			case oPDO::FETCH_CLASS:
			case oPDO::FETCH_CLASS|oPDO::FETCH_PROPS_LATE:
			case oPDO::FETCH_CLASS|oPDO::FETCH_CLASSTYPE:
				$className = !empty($this->fetchClassName) ? 
					$this->fetchClassName : array_shift($r);
				if(!is_string($className) || !class_exists($className)){
					$this->error("Class $className does not exist.");
					return false;
				}
				if(empty($this->fetchCtoargs)) $return = new $className;
				else{
					$rc = new ReflectionClass($className);
					$args = empty($this->fetchCtoargs) ? array() : $this->fetchCtoargs;
					$args = !is_array($args) ? array($args) : $args;
					$return = $rc->newInstanceArgs($args);
				}
				foreach($r as $k=>$v) $return->$k = $v;
				break;
			case oPDO::FETCH_INTO:
				foreach($r as $k=>$v) $this->fetchObject->$k = $v;
				$return = true;
				break;
			case oPDO::FETCH_LAZY:
				$return = new oPDORow($this->statement);
				$i = 0;
				foreach($r as $k=>$v){
					$return->$k = $v;
					$return->$i = $v;
				}
				break;
			case oPDO::FETCH_OBJ:
				$return = new stdClass();
				foreach($r as $k=>$v) $return->$k = $v;
				break;
			case oPDO::FETCH_NAMED:
			case oPDO::FETCH_ASSOC:
				// @todo properly implement FETCH_NAMED
				$return = $r;
				break;
			case oPDO::FETCH_NUM:
				$return = array_values($r);
				break;
			case oPDO::FETCH_BOUND:
				$keys = array_keys($r);
				$values = array_values($r);
				foreach($this->bindReferences as $column=>$info){
					$pullfrom = in_array($column, $keys) ? $r : $values;
					if(!isset($pullfrom[$column])){
						$this->error("Illegal offset: $column");
						return false;
					}
					switch($info['type']){
						case "PDO::PARAM_BOOL": $info['reference'] = !!$pullfrom[$column]; break;
						case "PDO::PARAM_NULL": $info['reference'] = null; break;
						case "PDO::PARAM_INT": $info['reference'] = intval($pullfrom[$column]); break;
						case "PDO::PARAM_LOB": case "PDO::PARAM_STR": $info['reference'] = strval($pullfrom[$column]); break;
						default: $info['reference'] = $pullfrom[$column]; break;
					}
				}
				$return = true;
			case oPDO::FETCH_BOTH;
				$return = array(); $i=0;
				foreach($r as $k=>$v){
					$return[$k] = $v;
					$return[$i] = $v;
					$i++;
				}
				break;
			case oPDO::FETCH_COLUMN:
				if(empty($this->fetchColNo)) $this->fetchColNo = 0;
				$vals = array_values($r);
				if(!isset($vals[$this->fetchColNo])){
					$this->error("Illegal column index: {$this->fetchColNo}");
					return false;
				}
				$return = $vals[$this->fetchColNo];
				break;
			case oPDO::FETCH_FUNC:
				if(!function_exists($this->fetchFunctionName)){
					$this->error("Function does not exist: {$this->fetchFunctionName}");
					return false;
				}
				$return = call_user_func_array($this->fetchFunctionName, array_values($r));
				break;
			default: 
				$this->error("Unknown Fetch mode");
				return false;
				break;
		}
		$this->resultSetPointer++;
		return $return;
	}
	
	/**
	 * Fetch all the result of the statement
	 * @param type $fetch_style
	 * @param type $fetch_argument
	 * @param type $ctor_args
	 * @return array
	 */
	public function fetchAll($fetch_style=false, &$fetch_argument=false, $ctor_args=array()){
		if(false !== $fetch_style) $this->setFetchMode($fetch_style, $fetch_argument, $ctor_args);
		$this->fetchedResultSet = array();
		while($res = $this->fetch()){
			if(is_bool($res)) return $res;
			array_push($this->fetchedResultSet, $res);
		}
		return $this->fetchedResultSet;
	}
	
	/**
	 * Fetch the column
	 * @param type $column_number
	 * @return mixed
	 */
	public function fetchColumn($column_number = 0){}
	
	/**
	 * Fetch an object using the returned parameters from the statement
	 * @param type $class_name
	 * @param type $ctor_args
	 * @return mixed
	 */
	public function fetchObject($class_name="stdClass", $ctor_args){}
	
	/**
	 * @param int $attribute
	 * @return mixed
	 */
	public function getAttribute($attribute){}
	
	/**
	 * @param int $column
	 * @return array
	 */
	public function getColumnMeta($column){}
	
	/**
	 * @return bool
	 */
	public function nextRowset(){}
	
	/**
	 * @return int
	 */
	public function rowCount(){}
	
	/**
	 * @param int $attribute
	 * @param mixed $value
	 * @return bool
	 */
	public function setAttribute($attribute, $value){}
	
	/**
	 * Set the fetch mode
	 * Note: When using FETCH_CLASS, it is always treated as though FETCH_PROPS_LATE
	 * is also given. I cannot emulate FETCH_CLASS without FETCH_PROPS_LATE.
	 * Note: Using FETCH_LAZY and FETCH_OBJ will return  an instance of stdClass 
	 * rather than an anonymous object
	 * @param int $mode
	 * @param mixed $param
	 * @param array $ctoargs
	 * @return boolean
	 */
	public function setFetchMode($mode, &$param=false, $ctoargs=array()){
		switch($mode){
			case oPDO::FETCH_CLASS:
			case oPDO::FETCH_CLASS|oPDO::FETCH_PROPS_LATE:
			case oPDO::FETCH_CLASS|oPDO::FETCH_CLASSTYPE:
				if(empty($param)) $param = "stdClass";
				if(!is_string($param) || !class_exists($param) && oPDO::FETCH_CLASS|oPDO::FETCH_CLASSTYPE !== $mode){
					$this->error("Class $param does not exist.");
					return false;
				}
				$this->fetchMode = oPDO::FETCH_CLASS;
				$this->fetchColNo = 0;
				$this->fetchClassName = $param;
				$this->fetchCtoargs = $ctoargs;
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case oPDO::FETCH_INTO:
				if(!is_object($param)) $param = new stdClass();
				$this->fetchMode = oPDO::FETCH_INTO;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = &$param;
				$this->fetchFunctionName = "";
				break;
			case oPDO::FETCH_LAZY:
			case oPDO::FETCH_OBJ:
			case oPDO::FETCH_NAMED:
			case oPDO::FETCH_NUM:
			case oPDO::FETCH_BOUND:
			case oPDO::FETCH_BOTH;
			case oPDO::FETCH_ASSOC:
				$this->fetchMode = $mode;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case oPDO::FETCH_COLUMN:
				$this->fetchMode = $mode;
				$this->fetchColNo = $param;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = "";
				break;
			case oPDO::FETCH_FUNC:
				if(!function_exists($param)){
					$this->error("Function does not exist: {$param}");
					return false;
				}
				$this->fetchMode = $mode;
				$this->fetchColNo = 0;
				$this->fetchClassName = "";
				$this->fetchCtoargs = array();
				$this->fetchObject = array();
				$this->fetchFunctionName = $param;
				break;
			default: 
				$this->error("Unknown fetch mode: $mode");
				return false;
				break;
		}
		return true;
	}
	
	//--------------------------------------------------------------------------
	// Helpers
	//--------------------------------------------------------------------------
	
	/**
	 * Throws the underlying OCI error
	 */
	public function error($msg){
		if(empty($msg) || !is_string($msg)){
			$m = oci_error();
			$msg = $e['message'];
			if(empty($msg)) $msg = "Unknown oPDO Error";
		}
		trigger_error(htmlentities($msg, ENT_QUOTES), E_USER_ERROR);
	}
	
	//--------------------------------------------------------------------------
	// Iterator methods
	//--------------------------------------------------------------------------
	
	public function rewind() {
		$this->fetchAll();
        $this->resultSetPointer = 0;
    }
	
	public function current() {
        return $this->fetchedResultSet[$this->resultSetPointer];
    }

    public function key() {
        return $this->resultSetPointer;
    }

    public function next() {
        $this->resultSetPointer++;
    }

    public function valid() {
        return isset($this->fetchedResultSet[$this->resultSetPointer]);
    }
}